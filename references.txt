vector3_t interpolate_vertex_color(Vertex_t a, Vertex_t b, Vertex_t c, float x_position, float y_position){
    float weight_vertex_a = ((b.raster_y - c.raster_y) * (x_position - c.raster_x) + (c.raster_x - b.raster_x) * (y_position - c.raster_y)) / ((b.raster_y - c.raster_y) * (a.raster_x - c.raster_x) + (c.raster_x - b.raster_x) * (a.raster_y - c.raster_y));
    float weight_vertex_b = ((c.raster_y - a.raster_y) * (x_position - c.raster_x) + (a.raster_x - c.raster_x) * (y_position - c.raster_y)) / ((b.raster_y - c.raster_y) * (a.raster_x - c.raster_x) + (c.raster_x - b.raster_x) * (a.raster_y - c.raster_y)); 
    float weight_vertex_C = 1 - weight_vertex_a - weight_vertex_b;                                                                                                               

    float red = (weight_vertex_C * c.color.r) + (weight_vertex_b * b.color.r) + (weight_vertex_a * a.color.r);
    float green = (weight_vertex_C * c.color.g) + (weight_vertex_b * b.color.g) + (weight_vertex_a * a.color.g);
    float blue = (weight_vertex_C * c.color.b) + (weight_vertex_b * b.color.b) + (weight_vertex_a * a.color.b);
    
    vector3_t to_return = vector3_new(red, green, blue);
    return to_return;
}

void rasterize(ctx_t *context, int index)
{
    //convert point in screen space
    //printf("%p",context->array_of_triangle + index);
    vector2_int_t vertex_a = point_to_screen(context->array_of_triangle[index].a.position.x, context->array_of_triangle[index].a.position.y, context->width, context->height);
    vector2_int_t vertex_b = point_to_screen(context->array_of_triangle[index].b.position.x, context->array_of_triangle[index].b.position.y, context->width, context->height);
    vector2_int_t vertex_c = point_to_screen(context->array_of_triangle[index].c.position.x, context->array_of_triangle[index].c.position.y, context->width, context->height);

    //set pixel position
    context->array_of_triangle[index].a.raster_x =  vertex_a.x;
    context->array_of_triangle[index].a.raster_y =  vertex_a.y;
    
    context->array_of_triangle[index].b.raster_x =  vertex_a.x;
    context->array_of_triangle[index].b.raster_y =  vertex_a.y;
    
    context->array_of_triangle[index].c.raster_x =  vertex_a.x;
    context->array_of_triangle[index].c.raster_y =  vertex_a.y;
    
    set_view_pos(context, &context->array_of_triangle[index]);
   
   
    //order from low y to high y
    vector2_int_t P[3] = {vertex_a, vertex_b, vertex_c};
    sort_vector(P);
  
    //printf(" 0: %f 1: %f 2: %f \n ",P[0].y,P[1].y,P[2].y );

    //calculate slope to know the orientation of triangle
    int slope;

    float value_0 = inversed_slope(P[0].x, P[1].x, P[0].y, P[1].y);
    float value_1 = inversed_slope(P[0].x, P[2].x, P[0].y, P[2].y);

    //if value 0 is bigger than 1 , p0 position is right else il left
    if (value_0 > value_1)
        slope = 0;
    else
        slope = 1;

    vector2_int_t p_3;
    float p2_magnitude = get_magnitude(P[0], P[2]);

    vector2_int_t for_dot = {.x = P[2].x - P[0].x, .y = P[2].y - P[0].y};
    float dot = dot_product(P[1], for_dot);

    //projecton of P[1] on P[2] vector
    //a = dot product(a,b) / pow( magnitude (b)) * x || y
    p_3.x = (dot / pow(p2_magnitude, 2)) * P[2].x;
    p_3.y = (dot / pow(p2_magnitude, 2)) * P[2].y;

    //Debug
    // printf("magnitude P1: %f\n", p1_magnitude);
    // printf("magnitude P2: %f\n", p2_magnitude);
    // printf("x: %f  y: %f\n", p_3.x, p_3.y);

    for (int i = P[0].y; i < P[1].y; i++)
    {
        //calculate gradient and find X
        float gradient_pixel_p0_p1 = 1;
        if(P[0].y != P[1].y)
             gradient_pixel_p0_p1 = gradient(i, P[0].y, P[1].y);
            
        float lerp_value_p0_p1 = lerp(P[0].x, P[1].x, gradient_pixel_p0_p1);

        float gradient_pixel_p0_p2 = 1;
        if(P[2].y != P[0].y)
             gradient_pixel_p0_p2 = gradient(i, P[2].y, P[0].y);
            
        float lerp_value_p0_p2 = lerp(P[0].x,P[2].x, gradient_pixel_p0_p2);

        vector2_int_t pixel;
        pixel.y = i;
        pixel.x = lerp_value_p0_p1;
        put_pixel(&pixel, context,0,0,0);

        //check slope , this is in case 0
        if (slope == 0)
        {
            for (int i = lerp_value_p0_p2; i < pixel.x; i++)
            {
                vector2_int_t half;
                half.y = pixel.y;
                half.x = i;
                put_pixel(&half, context,0,0,255);
            }
        }
        else
        {
            for (int i = pixel.x; i < lerp_value_p0_p2; i++)
            {
                vector2_int_t half;
                half.y = pixel.y;
                half.x = i;
                put_pixel(&half, context,0,0,255);
            }
        }
    }

    //da p3 a p2 sulla y e da lerp y a p1 sulla x
    for (int i = P[1].y; i < P[2].y; i++)
    {
        float gradient_pixel_p1_p2 = 1;
        if(P[1].y != P[2].y)
            gradient_pixel_p1_p2 = gradient(i, P[2].y, P[1].y);

        float lerp_value_p1_p2 = lerp(P[1].x, P[2].x, gradient_pixel_p1_p2);
        
        float gradient_pixel_p0_p2 = 1;
        if(P[2].y != P[0].y)
             gradient_pixel_p0_p2 = gradient(i, P[2].y, P[0].y);
            
        float lerp_value_p0_p2 = lerp(P[0].x,P[2].x, gradient_pixel_p0_p2);
        // float gradient_pixel_p3_p2 = 1;
        // if(P[0].y != P[2].y)
        //     gradient_pixel_p3_p2 = gradient(i,P[2].y, p_3.y );
            
        // float lerp_value_p3_p2 = lerp(p_3.x, P[2].x, gradient_pixel_p3_p2);
    
    //    printf("gradient:%f x0:%f  x1:%f\n",gradient_pixel_p3_p2, lerp_value_p3_p2, lerp_value_p1_p2);
        vector2_int_t pixel;
        pixel.y = i;
        pixel.x = lerp_value_p1_p2;
        put_pixel(&pixel, context,0,0,0);

        //check slope , this is in case 0
        if (slope == 0)
        {
            for (int i = lerp_value_p0_p2; i < pixel.x; i++)
            {
                vector2_int_t half;
                half.y = pixel.y;
                half.x = i;
                put_pixel(&half, context,0,0,255);
            }
        }
        else
        {
            for (int i = pixel.x; i < lerp_value_p0_p2; i++)
            {
                vector2_int_t half;
                half.y = pixel.y;
                half.x = i;
                put_pixel(&half, context,0,0,255);
            }
        }
    }

    //Draw wireframe
    draw_line(P[0].y, P[0].x, P[1].x, P[1].y, context);
    draw_line(P[0].y, P[0].x, P[2].x, P[2].y, context);
    draw_line(P[1].y, P[1].x, P[2].x, P[2].y, context);
    draw_line(p_3.y,P[0].x,p_3.x ,P[1].y, context);
}

//screen_point : 600 = point : 2

//SCREEN_POINT
//screen_point = x
//x : 600 = point : 2
//x = (600 * point)/2

//POINT
//point = x
//screen_point : width = x : 2
//x = (screen_point * 2 ) / width

void rendering(ctx_t * context, int index, unsigned char R, unsigned char G, unsigned char B)
{
    //Calculate field of view
    set_view_pos(context, &context->array_of_triangle[index]);
    
    //Sort vertex based on Y, from low to high
    vertex_t ordered[3]= {context->array_of_triangle[index].a,context->array_of_triangle[index].b,context->array_of_triangle[index].c};
    
    // vertex_t* ordered = malloc(sizeof(vertex_t)*3);
    // ordered[0] = context->array_of_triangle[index].a;
    // ordered[1] = context->array_of_triangle[index].b;
    // ordered[2] = context->array_of_triangle[index].c;

    vertex_t temp;

    if (ordered[1].raster_y < ordered[0].raster_y)
    {
        temp = ordered[0];
        ordered[0] = ordered[1];
        ordered[1] = temp;
    }

    if (ordered[2].raster_y < ordered[1].raster_y)
    {
        temp = ordered[2];
        ordered[2] = ordered[1];
        ordered[1] = temp;
    }

    if (ordered[1].raster_y < ordered[0].raster_y)
    {
        temp = ordered[0];
        ordered[0] = ordered[1];
        ordered[1] = temp;
    }
    
    //Debug
    // printf("0 :%f\n" ,   ordered[0].position.y);
    // printf("1 :%f\n" ,   ordered[1].position.y);
    // printf("2 :%f\n" ,   ordered[2].position.y);
    // printf("0 raster :%d\n" ,   ordered[0].raster_y);
    // printf("1 raster :%d\n" ,   ordered[1].raster_y);
    // printf("2 raster :%d\n" ,   ordered[2].raster_y);

    //calculate slope
  //  printf("x0 :%d x1:%d y0 : %d y1: %d\n",ordered[0].raster_x, ordered[1].raster_x, ordered[0].raster_y, ordered[1].raster_y);
   
    int slope;
    
    float value_0; 
    float value_1;

    if(ordered[0].raster_y == ordered[1].raster_y)
        value_0 = 1;
    else
        value_0 = inversed_slope(ordered[0].raster_x, ordered[1].raster_x, ordered[0].raster_y, ordered[1].raster_y);
    
    if(ordered[0].raster_y == ordered[2].raster_y)
        value_1 = 1;
    else
        value_1 = inversed_slope(ordered[0].raster_x, ordered[2].raster_x, ordered[0].raster_y, ordered[2].raster_y);
 
  //  float value_0 = inversed_slope(ordered[0].raster_x, ordered[1].raster_x, ordered[0].raster_y, ordered[1].raster_y);
  //  float value_1 = inversed_slope(ordered[0].raster_x, ordered[2].raster_x, ordered[0].raster_y, ordered[2].raster_y);

    //if value 0 is bigger than 1 , p0 position is right else il left
    if (value_0 > value_1)
        slope = 0;
    else
        slope = 1;

    //Debug
    // printf("value 0 :%f\n",value_0);
    // printf("value 1 :%f\n",value_1);
    // printf("slope :%d\n",slope);
    
    float gradient = 1;

    for (int i = ordered[0].raster_y; i < ordered[1].raster_y; i++)
    {
        //calculate gradient and find X
        float gradient_pixel_p0_p1 = 1;
        float gradient_pixel_p0_p2 = 1;
        
        //if there are point with same y , don' t calculate gradient
        if(ordered[0].raster_y != ordered[1].raster_y)
             gradient_pixel_p0_p1 = gradient(i, ordered[0].raster_y, ordered[1].raster_y);

        if(ordered[2].raster_y != ordered[0].raster_y)
             gradient_pixel_p0_p2 = gradient(i, ordered[0].raster_y, ordered[2].raster_y);

        //Thankful to lerp, we calculate the two point for drawing pixels            
        float x_start = lerp(ordered[0].raster_x, ordered[1].raster_x, gradient_pixel_p0_p1);
        float x_end = lerp(ordered[0].raster_x,ordered[2].raster_x, gradient_pixel_p0_p2);

       // put_pixel_from_point(context, x_start,i,255,0,0);

        if (slope == 0)
        {
            for (int j = x_start; j < x_end; j++)
                put_pixel_from_point(context, j,i,R,G,B);
    
        }
        else
        {
            for (int j = x_end; j < x_start; j++)
                put_pixel_from_point(context, j,i,R,G,B);
        }
    }

    for (int i = ordered[1].raster_y; i < ordered[2].raster_y; i++)
    {
        float gradient_pixel_p1_p2 = 1;
        float gradient_pixel_p0_p2 = 1;

        if(ordered[1].raster_y != ordered[2].raster_y)
            gradient_pixel_p1_p2 = gradient(i, ordered[1].raster_y, ordered[2].raster_y);

        if(ordered[2].raster_y != ordered[0].raster_y)
             gradient_pixel_p0_p2 = gradient(i, ordered[0].raster_y, ordered[2].raster_y);

        float x_start = lerp(ordered[1].raster_x, ordered[2].raster_x, gradient_pixel_p1_p2);
        float x_end = lerp(ordered[0].raster_x,ordered[2].raster_x, gradient_pixel_p0_p2);
    
        if (slope == 0)
        {
            for (int j = x_start; j < x_end; j++)
                put_pixel_from_point(context, j,i,R,G,B);
        }
        else
        {
            for (int j = x_end; j < x_start; j++)
                put_pixel_from_point(context, j,i,R,G,B);
        }
    }

    // for(int i = 0; i < 4; i++)
    //     free(&ordered[i]);
}

int *array_of_vector = NULL;
size_t array_of_vector_size = 0;

void append_vector(int value)
{
    array_of_vector_size++;
    int *resized_area = realloc(array_of_vector,sizeof(int)* array_of_vector_size);

    if(!resized_area)
    {
        //panic
        return;        
    }

    array_of_vector = resized_area;
    array_of_vector[array_of_vector_size-1] = value;
}